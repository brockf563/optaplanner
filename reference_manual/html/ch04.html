<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. Planner Configuration</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="OptaPlanner User Guide"/><link rel="up" href="index.html" title="OptaPlanner User Guide"/><link rel="prev" href="ch03.html" title="Chapter 3. Use Cases and Examples"/><link rel="next" href="ch05.html" title="Chapter 5. Score Calculation"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch03.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch05.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 4. Planner Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="plannerConfiguration"/>Chapter 4. Planner Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch04.html#plannerConfigurationOverview">4.1. Overview</a></span></dt><dt><span class="section"><a href="ch04.html#solverConfiguration">4.2. Solver Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#solverConfigurationByXML">4.2.1. Solver Configuration by XML</a></span></dt><dt><span class="section"><a href="ch04.html#solverConfigurationByJavaAPI">4.2.2. Solver Configuration by Java API</a></span></dt><dt><span class="section"><a href="ch04.html#annotationsConfiguration">4.2.3. Annotations Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="ch04.html#modelAPlanningProblem">4.3. Model a Planning Problem</a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#isThisClassAProblemFactOrPlanningEntity">4.3.1. Is This Class a Problem Fact or Planning Entity?</a></span></dt><dt><span class="section"><a href="ch04.html#problemFact">4.3.2. Problem Fact</a></span></dt><dt><span class="section"><a href="ch04.html#planningEntity">4.3.3. Planning Entity</a></span></dt><dt><span class="section"><a href="ch04.html#planningVariable">4.3.4. Planning Variable</a></span></dt><dt><span class="section"><a href="ch04.html#planningValueAndPlanningValueRange">4.3.5. Planning Value and Planning Value Range</a></span></dt><dt><span class="section"><a href="ch04.html#shadowVariable">4.3.6. Shadow Variable</a></span></dt><dt><span class="section"><a href="ch04.html#planningProblemAndPlanningSolution">4.3.7. Planning Problem and Planning Solution</a></span></dt></dl></dd><dt><span class="section"><a href="ch04.html#useTheSolver">4.4. Use the <code class="literal">Solver</code></a></span></dt><dd><dl><dt><span class="section"><a href="ch04.html#theSolverInterface">4.4.1. The <code class="literal">Solver</code> Interface</a></span></dt><dt><span class="section"><a href="ch04.html#solvingAProblem">4.4.2. Solving a Problem</a></span></dt><dt><span class="section"><a href="ch04.html#environmentMode">4.4.3. Environment Mode: Are There Bugs in my Code?</a></span></dt><dt><span class="section"><a href="ch04.html#logging">4.4.4. Logging Level: What is the <code class="literal">Solver</code> Doing?</a></span></dt><dt><span class="section"><a href="ch04.html#randomNumberGenerator">4.4.5. Random Number Generator</a></span></dt></dl></dd></dl></div><div class="section" title="4.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="plannerConfigurationOverview"/>4.1. Overview</h2></div></div></div><p>Solving a planning problem with Planner consists out of 5 steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>Model your planning problem</strong></span> as a class that implements the interface
        <code class="literal">Solution</code>, for example the class <code class="literal">NQueens</code>.</p></li><li class="listitem"><p><span class="bold"><strong>Configure a <code class="literal">Solver</code></strong></span>, for example a First Fit and Tabu
        Search solver for any <code class="literal">NQueens</code> instance.</p></li><li class="listitem"><p><span class="bold"><strong>Load a problem data set</strong></span> from your data layer, for example a 4 Queens
        instance. That is the planning problem.</p></li><li class="listitem"><p><span class="bold"><strong>Solve it</strong></span> with <code class="literal">Solver.solve(planningProblem)</code> which
        retuns the best solution found.</p></li></ol></div><div class="mediaobject"><img src="images/Chapter-Planner_configuration/inputOutputOverview.png"/></div></div><div class="section" title="4.2. Solver Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="solverConfiguration"/>4.2. Solver Configuration</h2></div></div></div><div class="section" title="4.2.1. Solver Configuration by XML"><div class="titlepage"><div><div><h3 class="title"><a id="solverConfigurationByXML"/>4.2.1. Solver Configuration by XML</h3></div></div></div><p>Build a <code class="literal">Solver</code> instance with the <code class="literal">SolverFactory</code>. Configure the
      <code class="literal">SolverFactory</code> with a solver configuration XML file, provided as a classpath resource (as
      definied by <code class="literal">ClassLoader.getResource()</code>):</p><pre><code class="language-java">       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
               "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");
       Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();</code></pre><p>In a typical project (following the Maven directory structure), that solverConfig XML file would be located
      at
      <code class="literal">$PROJECT_DIR/src/main/resources/org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml</code>.
      Alternatively, a <code class="literal">SolverFactory</code> can be created from a <code class="literal">File</code>, an
      <code class="literal">InputStream</code> or a <code class="literal">Reader</code> with methods such as
      <code class="literal">SolverFactory.createFromXmlFile()</code>. However, for portability reasons, a classpath resource is
      recommended.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>On some environments (<a class="link" href="ch16.html#integrationWithOSGi" title="16.4.2. OSGi">OSGi</a>, <a class="link" href="ch16.html#integrationWithJBossModules" title="16.4.1. JBoss Modules, WildFly and JBoss EAP">JBoss modules</a>, ...), classpath resources (such as the solver
        config, score DRL's and domain classes) in your jars might not be available to the default
        <code class="literal">ClassLoader</code> of the <code class="literal">optaplanner-core</code> jar. In those cases, provide the
        <code class="literal">ClassLoader</code> of your classes as a parameter:</p><pre><code class="language-java">       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
               ".../nqueensSolverConfig.xml", getClass().getClassLoader());</code></pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>When using Workbench or Execution Server or to take advantage of Drools's <code class="literal">KieContainer</code>
        features, provide the <code class="literal">KieContainer</code> as a parameter:</p><pre><code class="language-java">       KieServices kieServices = KieServices.Factory.get();
       KieContainer kieContainer = kieServices.newKieContainer(
               kieServices.newReleaseId("org.nqueens", "nqueens", "1.0.0"));
       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromKieContainerXmlResource(
               kieContainer, ".../nqueensSolverConfig.xml");</code></pre><p>And use <a class="link" href="ch05.html#droolsScoreCalculationKsessionName" title="5.3.4.2.3. A ksessionName in a Kjar from a Maven repository">a ksessionName in the solver
        configuration</a>.</p></div><p>Both a <code class="literal">Solver</code> and a <code class="literal">SolverFactory</code> have a generic type called
      <code class="literal">Solution_</code>, which is the class representing a <a class="link" href="ch04.html#planningProblemAndPlanningSolution" title="4.3.7. Planning Problem and Planning Solution">planning problem and solution</a>.</p><p>A solver configuration XML file looks like this:</p><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;

  &lt;!-- Define the score function --&gt;
  &lt;scoreDirectorFactory&gt;
    &lt;scoreDefinitionType&gt;SIMPLE&lt;/scoreDefinitionType&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
  &lt;/scoreDirectorFactory&gt;

  &lt;!-- Configure the optimization algorithms (optional) --&gt;
  &lt;termination&gt;
    ...
  &lt;/termination&gt;
  &lt;constructionHeuristic&gt;
    ...
  &lt;/constructionHeuristic&gt;
  &lt;localSearch&gt;
    ...
  &lt;/localSearch&gt;
&lt;/solver&gt;</code></pre><p>Notice the three parts in it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Define the model.</p></li><li class="listitem"><p>Define the score function.</p></li><li class="listitem"><p>Optionally configure the optimization algorithm(s).</p></li></ul></div><p>These various parts of a configuration are explained further in this manual.</p><p><span class="bold"><strong>Planner makes it relatively easy to switch optimization algorithm(s) just by changing
      the configuration.</strong></span> There is even a <a class="link" href="ch14.html" title="Chapter 14. Benchmarking And Tweaking">Benchmarker</a> which allows you to
      play out different configurations against each other and report the most appropriate configuration for your use
      case.</p></div><div class="section" title="4.2.2. Solver Configuration by Java API"><div class="titlepage"><div><div><h3 class="title"><a id="solverConfigurationByJavaAPI"/>4.2.2. Solver Configuration by Java API</h3></div></div></div><p>A solver configuration can also be configured with the <code class="literal">SolverConfig</code> API. This is
      especially useful to change some values dynamically at runtime. For example, to change the running time based on
      user input, before building the <code class="literal">Solver</code>:</p><pre><code class="language-java">        SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");

        TerminationConfig terminationConfig = new TerminationConfig();
        terminationConfig.setMinutesSpentLimit(userInput);
        solverFactory.getSolverConfig().setTerminationConfig(terminationConfig);

        Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();</code></pre><p>Every element in the solver configuration XML is available as a <code class="literal">*Config</code> class or a
      property on a <code class="literal">*Config</code> class in the package namespace
      <code class="literal">org.optaplanner.core.config</code>. These <code class="literal">*Config</code> classes are the Java
      representation of the XML format. They build the runtime components (of the package namespace
      <code class="literal">org.optaplanner.core.impl</code>) and assemble them into an efficient
      <code class="literal">Solver</code>.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>The <code class="literal">SolverFactory</code> is only multi-thread safe after its configured. So the
        <code class="literal">getSolverConfig()</code> method is not thread-safe. To configure a <code class="literal">SolverFactory</code>
        dynamically for each user request, build a <code class="literal">SolverFactory</code> as base during initialization and
        clone it with the <code class="literal">cloneSolverFactory()</code> method for a user request:</p><pre><code class="language-java">    private SolverFactory&lt;NQueens&gt; base;

    public void init() {
        base = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");
        base.getSolverConfig().setTerminationConfig(new TerminationConfig());
    }

    // Called concurrently from different threads
    public void userRequest(..., long userInput)
        SolverFactory&lt;NQueens&gt; solverFactory = base.cloneSolverFactory();
        solverFactory.getSolverConfig().getTerminationConfig().setMinutesSpentLimit(userInput);
        Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();
        ...
    }</code></pre></div></div><div class="section" title="4.2.3. Annotations Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="annotationsConfiguration"/>4.2.3. Annotations Configuration</h3></div></div></div><div class="section" title="4.2.3.1. Automatic Scanning for Annotations"><div class="titlepage"><div><div><h4 class="title"><a id="automaticScanningForAnnotations"/>4.2.3.1. Automatic Scanning for Annotations</h4></div></div></div><p>Instead of the declaring the classes that have a <code class="literal">@PlanningSolution</code> or
        <code class="literal">@PlanningEntity</code> manually:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;

  ...
&lt;/solver&gt;</code></pre><p>Planner can find scan the classpath and find them automatically:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;scanAnnotatedClasses/&gt;

  ...
&lt;/solver&gt;</code></pre><p>If there are multiple models in your classpath (or just to speed up scanning), specify the packages to
        scan:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;scanAnnotatedClasses&gt;
    &lt;packageInclude&gt;org.optaplanner.examples.cloudbalancing&lt;/packageInclude&gt;
  &lt;/scanAnnotatedClasses&gt;

  ...
&lt;/solver&gt;</code></pre><p>This will find all solution and entity classes in the package or subpackages.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If <code class="literal">scanAnnotatedClasses</code> is not specified, the <code class="literal">org.reflections</code>
          transitive maven dependency can be excluded.</p></div></div><div class="section" title="4.2.3.2. Annotation Alternatives"><div class="titlepage"><div><div><h4 class="title"><a id="annotationAlternatives"/>4.2.3.2. Annotation Alternatives</h4></div></div></div><p>Planner needs to be told which classes in your domain model are planning entities, which properties are
        planning variables, etc. There are several ways to deliver this information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Add class annotations and JavaBean property annotations on the domain model (recommended). The
            property annotations must be the getter method, not on the setter method. Such a getter does not need to be
            public.</p></li><li class="listitem"><p>Add class annotations and field annotations on the domain model. Such a field does not need to be
            public.</p></li><li class="listitem"><p>No annotations: externalize the domain configuration in an XML file. This is <a class="link" href="https://issues.jboss.org/browse/PLANNER-151">not yet supported</a>.</p></li></ul></div><p>This manual focuses on the first manner, but every features supports all 3 manners, even if it's not
        explicitly mentioned.</p></div></div></div><div class="section" title="4.3. Model a Planning Problem"><div class="titlepage"><div><div><h2 class="title"><a id="modelAPlanningProblem"/>4.3. Model a Planning Problem</h2></div></div></div><div class="section" title="4.3.1. Is This Class a Problem Fact or Planning Entity?"><div class="titlepage"><div><div><h3 class="title"><a id="isThisClassAProblemFactOrPlanningEntity"/>4.3.1. Is This Class a Problem Fact or Planning Entity?</h3></div></div></div><p>Look at a dataset of your planning problem. You will recognize domain classes in there, each of which can be
      categorized as one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A unrelated class: not used by any of the score constraints. From a planning standpoint, this data is
          obsolete.</p></li><li class="listitem"><p>A <span class="bold"><strong>problem fact</strong></span> class: used by the score constraints, but does NOT
          change during planning (as long as the problem stays the same). For example: <code class="literal">Bed</code>,
          <code class="literal">Room</code>, <code class="literal">Shift</code>, <code class="literal">Employee</code>, <code class="literal">Topic</code>,
          <code class="literal">Period</code>, ... All the properties of a problem fact class are problem properties.</p></li><li class="listitem"><p>A <span class="bold"><strong>planning entity</strong></span> class: used by the score constraints and changes
          during planning. For example: <code class="literal">BedDesignation</code>, <code class="literal">ShiftAssignment</code>,
          <code class="literal">Exam</code>, ... The properties that change during planning are planning variables. The other
          properties are problem properties.</p></li></ul></div><p>Ask yourself: <span class="emphasis"><em>What class changes during planning?</em></span> <span class="emphasis"><em>Which class has variables
      that I want the <code class="literal">Solver</code> to change for me?</em></span> That class is a planning entity. Most use
      cases have only one planning entity class. Most use cases also have only one planning variable per planning entity
      class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In <a class="link" href="ch15.html#realTimePlanning" title="15.5. Real-time Planning">real-time planning</a>, even though the problem itself changes,
        problem facts do not really change during planning, instead they change between planning (because the Solver
        temporarily stops to apply the problem fact changes).</p></div><p>A good model can greatly improve the success of your planning implementation. Follow these guidelines to
      design a good model:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In a <span class="emphasis"><em>many to one</em></span> relationship, it is normally the <span class="emphasis"><em>many</em></span> side
          that is the planning entity class. The property referencing the other side is then the planning variable. For
          example in employee rostering: the planning entity class is <code class="literal">ShiftAssignment</code>, not
          <code class="literal">Employee</code>, and the planning variable is <code class="literal">ShiftAssignment.getEmployee()</code>
          because one <code class="literal">Employee</code> has multiple <code class="literal">ShiftAssignment</code>s but one
          <code class="literal">ShiftAssignment</code> has only one <code class="literal">Employee</code>.</p></li><li class="listitem"><p>A planning entity class should have at least one problem property. A planning entity class with only
          planning variables can normally be simplified by converting one of those planning variables into a problem
          property. That heavily decreases <a class="link" href="ch06.html#searchSpaceSize" title="6.1. Search Space Size in the Real World">the search space size</a>. For example in
          employee rostering: the <code class="literal">ShiftAssignment</code>'s <code class="literal">getShift()</code> is a problem
          property and the <code class="literal">getEmployee()</code> is a planning variable. If both were a planning variable,
          solving it would be far less efficient.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A surrogate ID does not suffice as the required minimum of one problem property. It needs to be
              understandable by the business. A business key does suffice. This prevents an unassigned entity from being
              nameless (unidentifiable by the business).</p></li><li class="listitem"><p>This way, there is no need to add a hard constraint to assure that two planning entities are
              different: they are already different due to their problem properties.</p></li><li class="listitem"><p>In some cases, multiple planning entities have the same problem property. In such cases, it can be
              useful to create an extra problem property to distinguish them. For example in employee rostering:
              <code class="literal">ShiftAssignment</code> has besides the problem property <code class="literal">Shift</code> also the
              problem property <code class="literal">indexInShift</code>.</p></li></ul></div></li><li class="listitem"><p>The number of planning entities is recommended to be fixed during planning. When unsure of which
          property should be a planning variable and which should be a problem property, choose it so the number of
          planning entities is fixed. For example in employee rostering: if the planning entity class would have been
          <code class="literal">EmployeeAssignment</code> with a problem property <code class="literal">getEmployee()</code> and a planning
          variable <code class="literal">getShift()</code>, than it is impossible to accurately predict how many
          <code class="literal">EmployeeAssignment</code> instances to make per <code class="literal">Employee</code>.</p></li></ul></div><p>For inspiration, take a look at <a class="link" href="ch17.html" title="Chapter 17. Design Patterns">typical design patterns</a> or how the
      examples modeled their domain:</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/entityVariableAndValueExamples.png"/></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Vehicle routing is special, because it uses a <a class="link" href="ch04.html#chainedPlanningVariable" title="4.3.5.4. Chained Planning Variable (TSP, VRP, ...)">chained planning
        variable</a>.</p></div><p><span class="bold"><strong>In Planner, all problems facts and planning entities are plain old JavaBeans
      (POJOs).</strong></span> Load them from a database, an XML file, a data repository, a REST service, a noSQL cloud, ...
      (see <a class="link" href="ch16.html" title="Chapter 16. Integration">integration</a>): it doesn't matter.</p></div><div class="section" title="4.3.2. Problem Fact"><div class="titlepage"><div><div><h3 class="title"><a id="problemFact"/>4.3.2. Problem Fact</h3></div></div></div><p>A problem fact is any JavaBean (POJO) with getters that does not change during planning. Implementing the
      interface <code class="literal">Serializable</code> is recommended (but not required). For example in n queens, the columns
      and rows are problem facts:</p><pre><code class="language-java">public class Column implements Serializable {

    private int index;

    // ... getters
}</code></pre><pre><code class="language-java">public class Row implements Serializable {

    private int index;

    // ... getters
}</code></pre><p>A problem fact can reference other problem facts of course:</p><pre><code class="language-java">public class Course implements Serializable {

    private String code;

    private Teacher teacher; // Other problem fact
    private int lectureSize;
    private int minWorkingDaySize;

    private List&lt;Curriculum&gt; curriculumList; // Other problem facts
    private int studentSize;

    // ... getters
}</code></pre><p>A problem fact class does <span class="emphasis"><em>not</em></span> require any Planner specific code. For example, you can
      reuse your domain classes, which might have JPA annotations.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Generally, better designed domain classes lead to simpler and more efficient score constraints. Therefore,
        when dealing with a messy (denormalized) legacy system, it can sometimes be worthwhile to convert the messy
        domain model into a Planner specific model first. For example: if your domain model has two
        <code class="literal">Teacher</code> instances for the same teacher that teaches at two different departments, it is
        harder to write a correct score constraint that constrains a teacher's spare time on the original model than on
        an adjusted model.</p><p>Alternatively, you can sometimes also introduce <a class="link" href="ch04.html#cachedProblemFact" title="4.3.7.5.1. Cached Problem Fact"><span class="emphasis"><em>a cached
        problem fact</em></span></a> to enrich the domain model for planning only.</p></div></div><div class="section" title="4.3.3. Planning Entity"><div class="titlepage"><div><div><h3 class="title"><a id="planningEntity"/>4.3.3. Planning Entity</h3></div></div></div><div class="section" title="4.3.3.1. Planning Entity Annotation"><div class="titlepage"><div><div><h4 class="title"><a id="planningEntityAnnotation"/>4.3.3.1. Planning Entity Annotation</h4></div></div></div><p>A planning entity is a JavaBean (POJO) that changes during solving, for example a <code class="literal">Queen</code>
        that changes to another row. A planning problem has multiple planning entities, for example for a single n
        queens problem, each <code class="literal">Queen</code> is a planning entity. But there is usually only one planning
        entity class, for example the <code class="literal">Queen</code> class.</p><p>A planning entity class needs to be annotated with the <code class="literal">@PlanningEntity</code>
        annotation.</p><p>Each planning entity class has one or more <span class="emphasis"><em>planning variables</em></span>. It should also have
        one or more <span class="emphasis"><em>defining</em></span> properties. For example in n queens, a <code class="literal">Queen</code> is
        defined by its <code class="literal">Column</code> and has a planning variable <code class="literal">Row</code>. This means that a
        Queen's column never changes during solving, while its row does change.</p><pre><code class="language-java">@PlanningEntity
public class Queen {

    private Column column;

    // Planning variables: changes during planning, between score calculations.
    private Row row;

    // ... getters and setters
}</code></pre><p>A planning entity class can have multiple planning variables. For example, a <code class="literal">Lecture</code> is
        defined by its <code class="literal">Course</code> and its index in that course (because one course has multiple
        lectures). Each <code class="literal">Lecture</code> needs to be scheduled into a <code class="literal">Period</code> and a
        <code class="literal">Room</code> so it has two planning variables (period and room). For example: the course Mathematics
        has eight lectures per week, of which the first lecture is Monday morning at 08:00 in room 212.</p><pre><code class="language-java">@PlanningEntity
public class Lecture {

    private Course course;
    private int lectureIndexInCourse;

    // Planning variables: changes during planning, between score calculations.
    private Period period;
    private Room room;

    // ...
}</code></pre><p>Without <a class="link" href="ch04.html#automaticScanningForAnnotations" title="4.2.3.1. Automatic Scanning for Annotations">automated scanning</a>, the solver
        configuration also needs to declare each planning entity class:</p><pre><code class="language-java">&lt;solver&gt;
  ...
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;
  ...
&lt;/solver&gt;</code></pre><p>Some uses cases have multiple planning entity classes. For example: route freight and trains into railway
        network arcs, where each freight can use multiple trains over its journey and each train can carry multiple
        freights per arc. Having multiple planning entity classes directly raises the implementation complexity of your
        use case.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><span class="emphasis"><em>Do not create unnecessary planning entity classes.</em></span> This leads to difficult
          <code class="literal">Move</code> implementations and slower score calculation.</p><p>For example, do not create a planning entity class to hold the total free time of a teacher, which needs
          to be kept up to date as the <code class="literal">Lecture</code> planning entities change. Instead, calculate the free
          time in the score constraints (or as a <a class="link" href="ch04.html#shadowVariable" title="4.3.6. Shadow Variable">shadow variable</a>) and put the
          result per teacher into a logically inserted score object.</p><p>If historic data needs to be considered too, then create problem fact to hold the total of the historic
          assignments up to, but <span class="emphasis"><em>not including</em></span>, the planning window (so that it does not change
          when a planning entity changes) and let the score constraints take it into account.</p></div></div><div class="section" title="4.3.3.2. Planning Entity Difficulty"><div class="titlepage"><div><div><h4 class="title"><a id="planningEntityDifficulty"/>4.3.3.2. Planning Entity Difficulty</h4></div></div></div><p>Some optimization algorithms work more efficiently if they have an estimation of which planning entities
        are more difficult to plan. For example: in bin packing bigger items are harder to fit, in course scheduling
        lectures with more students are more difficult to schedule, and in n queens the middle queens are more difficult
        to fit on the board.</p><p>Therefore, you can set a <code class="literal">difficultyComparatorClass</code> to the
        <code class="literal">@PlanningEntity</code> annotation:</p><pre><code class="language-java">@PlanningEntity(difficultyComparatorClass = CloudProcessDifficultyComparator.class)
public class CloudProcess {
    // ...
}</code></pre><pre><code class="language-java">public class CloudProcessDifficultyComparator implements Comparator&lt;CloudProcess&gt; {

    public int compare(CloudProcess a, CloudProcess b) {
        return new CompareToBuilder()
                .append(a.getRequiredMultiplicand(), b.getRequiredMultiplicand())
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</code></pre><p>Alternatively, you can also set a <code class="literal">difficultyWeightFactoryClass</code> to the
        <code class="literal">@PlanningEntity</code> annotation, so that you have access to the rest of the problem facts from the
        <code class="literal">Solution</code> too:</p><pre><code class="language-java">@PlanningEntity(difficultyWeightFactoryClass = QueenDifficultyWeightFactory.class)
public class Queen {
    // ...
}</code></pre><p>See <a class="link" href="ch07.html#sortedSelection" title="7.6.5. Sorted Selection">sorted selection</a> for more information.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Difficulty should be implemented ascending: easy entities are lower, difficult entities are higher. For
          example, in bin packing: small item &lt; medium item &lt; big item.</p><p>Although most algorithms start with the more difficult entities first, they just reverse the
          ordering.</p></div><p><span class="emphasis"><em>None of the current planning variable states should be used to compare planning entity
        difficulty.</em></span> During Construction Heuristics, those variables are likely to be <code class="literal">null</code>
        anyway. For example, a <code class="literal">Queen</code>'s <code class="literal">row</code> variable should not be used.</p></div></div><div class="section" title="4.3.4. Planning Variable"><div class="titlepage"><div><div><h3 class="title"><a id="planningVariable"/>4.3.4. Planning Variable</h3></div></div></div><div class="section" title="4.3.4.1. Planning Variable Annotation"><div class="titlepage"><div><div><h4 class="title"><a id="planningVariableAnnotation"/>4.3.4.1. Planning Variable Annotation</h4></div></div></div><p>A planning variable is a JavaBean property (so a getter and setter) on a planning entity. It points to a
        planning value, which changes during planning. For example, a <code class="literal">Queen</code>'s <code class="literal">row</code>
        property is a planning variable. Note that even though a <code class="literal">Queen</code>'s <code class="literal">row</code>
        property changes to another <code class="literal">Row</code> during planning, no <code class="literal">Row</code> instance itself is
        changed.</p><p>A planning variable getter needs to be annotated with the <code class="literal">@PlanningVariable</code> annotation,
        which needs a non-empty <code class="literal">valueRangeProviderRefs</code> property.</p><pre><code class="language-java">@PlanningEntity
public class Queen {
    ...

    private Row row;

    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    public Row getRow() {
        return row;
    }

    public void setRow(Row row) {
        this.row = row;
    }

}</code></pre><p>The <code class="literal">valueRangeProviderRefs</code> property defines what are the possible planning values for
        this planning variable. It references one or more <code class="literal">@ValueRangeProvider</code>
        <code class="literal">id</code>'s.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A @PlanningVariable annotation needs to be on a member in a class with a @PlanningEntity annotation. It
          is ignored on parent classes or subclasses without that annotation.</p></div><p><a class="link" href="ch04.html#annotationAlternatives" title="4.2.3.2. Annotation Alternatives">Annotating the field</a> instead of the property works
        too:</p><pre><code class="language-java">@PlanningEntity
public class Queen {
    ...

    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    private Row row;

}</code></pre></div><div class="section" title="4.3.4.2. Nullable Planning Variable"><div class="titlepage"><div><div><h4 class="title"><a id="nullablePlanningVariable"/>4.3.4.2. Nullable Planning Variable</h4></div></div></div><p>By default, an initialized planning variable cannot be <code class="literal">null</code>, so an initialized solution
        will never use <code class="literal">null</code> for any of its planning variables. In an over-constrained use case, this
        can be counterproductive. For example: in task assignment with too many tasks for the workforce, we would rather
        leave low priority tasks unassigned instead of assigning them to an overloaded worker.</p><p>To allow an initialized planning variable to be <code class="literal">null</code>, set <code class="literal">nullable</code>
        to <code class="literal">true</code>:</p><pre><code class="language-java">    @PlanningVariable(..., nullable = true)
    public Worker getWorker() {
        return worker;
    }</code></pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Planner will automatically add the value <code class="literal">null</code> to the value range. There is no need to
          add <code class="literal">null</code> in a collection used by a <code class="literal">ValueRangeProvider</code>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Using a nullable planning variable implies that your score calculation is responsible for punishing (or
          even rewarding) variables with a null value.</p></div><p><a class="link" href="ch15.html" title="Chapter 15. Repeated Planning">Repeated planning</a> (especially <a class="link" href="ch15.html#realTimePlanning" title="15.5. Real-time Planning">real-time planning</a>) does not mix well with a nullable planning variable. Every
        time the Solver starts or a problem fact change is made, the <a class="link" href="ch09.html" title="Chapter 9. Construction Heuristics">Construction
        Heuristics</a> will try to initialize all the <code class="literal">null</code> variables again, which can be a huge
        waste of time. One way to deal with this, is to change when a planning entity should be reinitialized with an
        <code class="literal">reinitializeVariableEntityFilter</code>:</p><pre><code class="language-java">    @PlanningVariable(..., nullable = true, reinitializeVariableEntityFilter = ReinitializeTaskFilter.class)
    public Worker getWorker() {
        return worker;
    }</code></pre></div><div class="section" title="4.3.4.3. When is a Planning Variable Considered Initialized?"><div class="titlepage"><div><div><h4 class="title"><a id="whenIsAPlanningVariableInitialized"/>4.3.4.3. When is a Planning Variable Considered Initialized?</h4></div></div></div><p>A planning variable is considered initialized if its value is not <code class="literal">null</code> or if the
        variable is <code class="literal">nullable</code>. So a nullable variable is always considered initialized, even when a
        custom <code class="literal">reinitializeVariableEntityFilter</code> triggers a reinitialization during construction
        heuristics.</p><p>A planning entity is initialized if all of its planning variables are initialized.</p><p>A <code class="literal">Solution</code> is initialized if all of its planning entities are initialized.</p></div></div><div class="section" title="4.3.5. Planning Value and Planning Value Range"><div class="titlepage"><div><div><h3 class="title"><a id="planningValueAndPlanningValueRange"/>4.3.5. Planning Value and Planning Value Range</h3></div></div></div><div class="section" title="4.3.5.1. Planning Value"><div class="titlepage"><div><div><h4 class="title"><a id="planningValue"/>4.3.5.1. Planning Value</h4></div></div></div><p>A planning value is a possible value for a planning variable. Usually, a planning value is a problem fact,
        but it can also be any object, for example a <code class="literal">double</code>. It can even be another planning entity
        or even a interface implemented by both a planning entity and a problem fact.</p><p>A planning value range is the set of possible planning values for a planning variable. This set can be a
        countable (for example row <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code> or
        <code class="literal">4</code>) or uncountable (for example any <code class="literal">double</code> between <code class="literal">0.0</code>
        and <code class="literal">1.0</code>).</p></div><div class="section" title="4.3.5.2. Planning Value Range Provider"><div class="titlepage"><div><div><h4 class="title"><a id="planningValueRangeProvider"/>4.3.5.2. Planning Value Range Provider</h4></div></div></div><div class="section" title="4.3.5.2.1. Overview"><div class="titlepage"><div><div><h5 class="title"><a id="planningValueRangeProviderOverview"/>4.3.5.2.1. Overview</h5></div></div></div><p>The value range of a planning variable is defined with the <code class="literal">@ValueRangeProvider</code>
          annotation. A <code class="literal">@ValueRangeProvider</code> annotation always has a property <code class="literal">id</code>,
          which is referenced by the <code class="literal">@PlanningVariable</code>'s property
          <code class="literal">valueRangeProviderRefs</code>.</p><p>This annotation can be located on 2 types of methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On the Solution: All planning entities share the same value range.</p></li><li class="listitem"><p>On the planning entity: The value range differs per planning entity. This is less common.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A @ValueRangeProvider annotation needs to be on a member in a class with a @PlanningSolution or a
            @PlanningEntity annotation. It is ignored on parent classes or subclasses without those annotations.</p></div><p>The return type of that method can be 2 types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">Collection</code>: The value range is defined by a <code class="literal">Collection</code>
              (usually a <code class="literal">List</code>) of its possible values.</p></li><li class="listitem"><p><code class="literal">ValueRange</code>: The value range is defined by its bounds. This is less common.</p></li></ul></div></div><div class="section" title="4.3.5.2.2. ValueRangeProvider on the Solution"><div class="titlepage"><div><div><h5 class="title"><a id="valueRangeProviderOnSolution"/>4.3.5.2.2. <code class="literal">ValueRangeProvider</code> on the <code class="literal">Solution</code></h5></div></div></div><p>All instances of the same planning entity class share the same set of possible planning values for that
          planning variable. This is the most common way to configure a value range.</p><p>The <code class="literal">Solution</code> implementation has method that returns a <code class="literal">Collection</code>
          (or a <code class="literal">ValueRange</code>). Any value from that <code class="literal">Collection</code> is a possible planning
          value for this planning variable.</p><pre><code class="language-java">    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    public Row getRow() {
        return row;
    }</code></pre><pre><code class="language-java">@PlanningSolution
public class NQueens implements Solution&lt;SimpleScore&gt; {

    // ...

    @ValueRangeProvider(id = "rowRange")
    public List&lt;Row&gt; getRowList() {
        return rowList;
    }

}</code></pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>That <code class="literal">Collection</code> (or <code class="literal">ValueRange</code>) must not contain the value
            <code class="literal">null</code>, not even for a <a class="link" href="ch04.html#nullablePlanningVariable" title="4.3.4.2. Nullable Planning Variable">nullable planning
            variable</a>.</p></div><p><a class="link" href="ch04.html#annotationAlternatives" title="4.2.3.2. Annotation Alternatives">Annotating the field</a> instead of the property works
          too:</p><pre><code class="language-java">@PlanningSolution
public class NQueens implements Solution&lt;SimpleScore&gt; {
    ...

    @ValueRangeProvider(id = "rowRange")
    private List&lt;Row&gt; rowList;

}</code></pre></div><div class="section" title="4.3.5.2.3. ValueRangeProvider on the Planning Entity"><div class="titlepage"><div><div><h5 class="title"><a id="valueRangeProviderOnPlanningEntity"/>4.3.5.2.3. <code class="literal">ValueRangeProvider</code> on the Planning Entity</h5></div></div></div><p>Each planning entity has its own value range (a set of possible planning values) for the planning
          variable. For example, if a teacher can <span class="bold"><strong>never</strong></span> teach in a room that does not
          belong to his department, lectures of that teacher can limit their room value range to the rooms of his
          department.</p><pre><code class="language-java">    @PlanningVariable(valueRangeProviderRefs = {"departmentRoomRange"})
    public Room getRoom() {
        return room;
    }

    @ValueRangeProvider(id = "departmentRoomRange")
    public List&lt;Room&gt; getPossibleRoomList() {
        return getCourse().getTeacher().getDepartment().getRoomList();
    }</code></pre><p>Never use this to enforce a soft constraint (or even a hard constraint when the problem might not have a
          feasible solution). For example: <span class="emphasis"><em>Unless there is no other way</em></span>, a teacher can not teach in
          a room that does not belong to his department. In this case, the teacher should <span class="emphasis"><em>not</em></span> be
          limited in his room value range (because sometimes there is no other way).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>By limiting the value range specifically of one planning entity, you are effectively creating a
            <span class="emphasis"><em>built-in hard constraint</em></span>. This can have the benefit of severely lowering the number of
            possible solutions; however, it can also away the freedom of the optimization algorithms to temporarily
            break that constraint in order to escape from a local optimum.</p></div><p>A planning entity should <span class="emphasis"><em>not</em></span> use other planning entities to determinate its value
          range. That would only try to make the planning entity solve the planning problem itself and interfere with
          the optimization algorithms.</p><p>Every entity has its own <code class="literal">List</code> instance, unless multiple entities have the same value
          range. For example, if teacher A and B belong to the same department, they use the same
          <code class="literal">List&lt;Room&gt;</code> instance. Furthermore, each <code class="literal">List</code> contains a subset of
          the same set of planning value instances. For example, if department A and B can both use room X, then their
          <code class="literal">List&lt;Room&gt;</code> instances contain the same <code class="literal">Room</code> instance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A <code class="literal">ValueRangeProvider</code> on the planning entity consumes more memory than
            <code class="literal">ValueRangeProvider</code> on the Solution and disables certain automatic performance
            optimizations.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>A <code class="literal">ValueRangeProvider</code> on the planning entity is not currently compatible with a
            <a class="link" href="ch04.html#chainedPlanningVariable" title="4.3.5.4. Chained Planning Variable (TSP, VRP, ...)">chained</a> variable.</p></div></div><div class="section" title="4.3.5.2.4. ValueRangeFactory"><div class="titlepage"><div><div><h5 class="title"><a id="valueRangeFactory"/>4.3.5.2.4. <code class="literal">ValueRangeFactory</code></h5></div></div></div><p>Instead of a <code class="literal">Collection</code>, you can also return a <code class="literal">ValueRange</code> or
          <code class="literal">CountableValueRange</code>, build by the <code class="literal">ValueRangeFactory</code>:</p><pre><code class="language-java">    @ValueRangeProvider(id = "delayRange")
    public CountableValueRange&lt;Integer&gt; getDelayRange() {
        return ValueRangeFactory.createIntValueRange(0, 5000);
    }</code></pre><p>A <code class="literal">ValueRange</code> uses far less memory, because it only holds the bounds. In the example
          above, a <code class="literal">Collection</code> would need to hold all <code class="literal">5000</code> ints, instead of just
          the two bounds.</p><p>Furthermore, an <code class="literal">incrementUnit</code> can be specified, for example if you have to buy stocks
          in units of 200 pieces:</p><pre><code class="language-java">    @ValueRangeProvider(id = "stockAmountRange")
    public CountableValueRange&lt;Integer&gt; getStockAmountRange() {
         // Range: 0, 200, 400, 600, ..., 9999600, 9999800, 10000000
        return ValueRangeFactory.createIntValueRange(0, 10000000, 200);
    }</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Return <code class="literal">CountableValueRange</code> instead of <code class="literal">ValueRange</code> whenever
            possible (so Planner knows that it's countable).</p></div><p>The <code class="literal">ValueRangeFactory</code> has creation methods for several value class types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">int</code>: A 32bit integer range.</p></li><li class="listitem"><p><code class="literal">long</code>: A 64bit integer range.</p></li><li class="listitem"><p><code class="literal">double</code>: A 64bit floating point range which only supports random selection
              (because it does not implement <code class="literal">CountableValueRange</code>).</p></li><li class="listitem"><p><code class="literal">BigInteger</code>: An arbitrary-precision integer range.</p></li><li class="listitem"><p><code class="literal">BigDecimal</code>: A decimal point range. By default, the increment unit is the lowest
              non-zero value in the scale of the bounds.</p></li></ul></div></div><div class="section" title="4.3.5.2.5. Combine ValueRangeProviders"><div class="titlepage"><div><div><h5 class="title"><a id="combineValueRangeProviders"/>4.3.5.2.5. Combine ValueRangeProviders</h5></div></div></div><p>Value range providers can be combined, for example:</p><pre><code class="language-java">    @PlanningVariable(valueRangeProviderRefs = {"companyCarRange", "personalCarRange"})
    public Car getCar() {
        return car;
    }</code></pre><pre><code class="language-java">    @ValueRangeProvider(id = "companyCarRange")
    public List&lt;CompanyCar&gt; getCompanyCarList() {
        return companyCarList;
    }

    @ValueRangeProvider(id = "personalCarRange")
    public List&lt;PersonalCar&gt; getPersonalCarList() {
        return personalCarList;
    }</code></pre></div></div><div class="section" title="4.3.5.3. Planning Value Strength"><div class="titlepage"><div><div><h4 class="title"><a id="planningValueStrength"/>4.3.5.3. Planning Value Strength</h4></div></div></div><p>Some optimization algorithms work more efficiently if they have an estimation of which planning values are
        stronger, which means they are more likely to satisfy a planning entity. For example: in bin packing bigger
        containers are more likely to fit an item and in course scheduling bigger rooms are less likely to break the
        student capacity constraint.</p><p>Therefore, you can set a <code class="literal">strengthComparatorClass</code> to the
        <code class="literal">@PlanningVariable</code> annotation:</p><pre><code class="language-java">    @PlanningVariable(..., strengthComparatorClass = CloudComputerStrengthComparator.class)
    public CloudComputer getComputer() {
        // ...
    }</code></pre><pre><code class="language-java">public class CloudComputerStrengthComparator implements Comparator&lt;CloudComputer&gt; {

    public int compare(CloudComputer a, CloudComputer b) {
        return new CompareToBuilder()
                .append(a.getMultiplicand(), b.getMultiplicand())
                .append(b.getCost(), a.getCost()) // Descending (but this is debatable)
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If you have multiple planning value classes in the <span class="emphasis"><em>same</em></span> value range, the
          <code class="literal">strengthComparatorClass</code> needs to implement a <code class="literal">Comparator</code> of a common
          superclass (for example <code class="literal">Comparator&lt;Object&gt;</code>) and be able to handle comparing instances
          of those different classes.</p></div><p>Alternatively, you can also set a <code class="literal">strengthWeightFactoryClass</code> to the
        <code class="literal">@PlanningVariable</code> annotation, so you have access to the rest of the problem facts from the
        solution too:</p><pre><code class="language-java">    @PlanningVariable(..., strengthWeightFactoryClass = RowStrengthWeightFactory.class)
    public Row getRow() {
        // ...
    }</code></pre><p>See <a class="link" href="ch07.html#sortedSelection" title="7.6.5. Sorted Selection">sorted selection</a> for more information.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>Strength should be implemented ascending: weaker values are lower, stronger values are higher. For
          example in bin packing: small container &lt; medium container &lt; big container.</p></div><p><span class="emphasis"><em>None of the current planning variable state in any of the planning entities should be used to
        compare planning values.</em></span> During construction heuristics, those variables are likely to be
        <code class="literal">null</code>. For example, none of the <code class="literal">row</code> variables of any
        <code class="literal">Queen</code> may be used to determine the strength of a <code class="literal">Row</code>.</p></div><div class="section" title="4.3.5.4. Chained Planning Variable (TSP, VRP, ...)"><div class="titlepage"><div><div><h4 class="title"><a id="chainedPlanningVariable"/>4.3.5.4. Chained Planning Variable (TSP, VRP, ...)</h4></div></div></div><p>Some use cases, such as TSP and Vehicle Routing, require <span class="emphasis"><em>chaining</em></span>. This means the
        planning entities point to each other and form a chain. By modeling the problem as a set of chains (instead of a
        set of trees/loops), the search space is heavily reduced.</p><p>A planning variable that is chained either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Directly points to a problem fact (or planning entity), which is called an
            <span class="emphasis"><em>anchor</em></span>.</p></li><li class="listitem"><p>Points to another planning entity with the same planning variable, which recursively points to an
            anchor.</p></li></ul></div><p>Here are some example of valid and invalid chains:</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/chainPrinciples.png"/></div><p><span class="bold"><strong>Every initialized planning entity is part of an open-ended chain that begins from an
        anchor.</strong></span> A valid model means that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A chain is never a loop. The tail is always open.</p></li><li class="listitem"><p>Every chain always has exactly one anchor. The anchor is a problem fact, never a planning
            entity.</p></li><li class="listitem"><p>A chain is never a tree, it is always a line. Every anchor or planning entity has at most one trailing
            planning entity.</p></li><li class="listitem"><p>Every initialized planning entity is part of a chain.</p></li><li class="listitem"><p>An anchor with no planning entities pointing to it, is also considered a chain.</p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>A planning problem instance given to the <code class="literal">Solver</code> must be valid.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If your constraints dictate a closed chain, model it as an open-ended chain (which is easier to persist
          in a database) and implement a score constraint for the last entity back to the anchor.</p></div><p>The optimization algorithms and built-in <code class="literal">Move</code>s do chain correction to guarantee that
        the model stays valid:</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/chainCorrection.png"/></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>A custom <code class="literal">Move</code> implementation must leave the model in a valid state.</p></div><p>For example, in TSP the anchor is a <code class="literal">Domicile</code> (in vehicle routing it is
        <code class="literal">Vehicle</code>):</p><pre><code class="language-java">public class Domicile ... implements Standstill {

    ...

    public City getCity() {...}

}</code></pre><p>The anchor (which is a problem fact) and the planning entity implement a common interface, for example
        TSP's <code class="literal">Standstill</code>:</p><pre><code class="language-java">public interface Standstill {

    City getCity();

}</code></pre><p>That interface is the return type of the planning variable. Furthermore, the planning variable is chained.
        For example TSP's <code class="literal">Visit</code> (in vehicle routing it is <code class="literal">Customer</code>):</p><pre><code class="language-java">@PlanningEntity
public class Visit ... implements Standstill {

    ...

    public City getCity() {...}

    @PlanningVariable(graphType = PlanningVariableGraphType.CHAINED,
        valueRangeProviderRefs = {"domicileRange", "visitRange"})
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    public void setPreviousStandstill(Standstill previousStandstill) {
        this.previousStandstill = previousStandstill;
    }

}</code></pre><p>Notice how two value range providers are usually combined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The value range provider that holds the anchors, for example <code class="literal">domicileList</code>.</p></li><li class="listitem"><p>The value range provider that holds the initialized planning entities, for example
            <code class="literal">visitList</code>.</p></li></ul></div></div></div><div class="section" title="4.3.6. Shadow Variable"><div class="titlepage"><div><div><h3 class="title"><a id="shadowVariable"/>4.3.6. Shadow Variable</h3></div></div></div><div class="section" title="4.3.6.1. Introduction"><div class="titlepage"><div><div><h4 class="title"><a id="shadowVariableIntroduction"/>4.3.6.1. Introduction</h4></div></div></div><p>A shadow variable is a variable whose correct value can be deduced from the state of the genuine planning
        variables. Even though such a variable violates the principle of normalization by definition, in some use cases
        it can be very practical to use a shadow variable, especially to express the constraints more naturally. For
        example in vehicle routing with time windows: the arrival time at a customer for a vehicle can be calculated
        based on the previously visited customers of that vehicle (and the known travel times between two
        locations).</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/planningVariableListener.png"/></div><p>When the customers for a vehicle change, the arrival time for each customer is automatically adjusted. For
        more information, see the <a class="link" href="ch03.html#vehicleRoutingDomainModel" title="3.3.3.3. Domain Model">vehicle routing domain model</a>.</p><p>From a score calculation perspective, a shadow variable is like any other planning variable. From an
        optimization perspective, Planner effectively only optimizes the genuine variables (and mostly ignores the
        shadow variables): it just assures that when a genuine variable changes, any dependent shadow variables are
        changed accordingly.</p><p>There are several build-in shadow variables:</p></div><div class="section" title="4.3.6.2. Bi-directional Variable (Inverse Relation Shadow Variable)"><div class="titlepage"><div><div><h4 class="title"><a id="bidirectionalVariable"/>4.3.6.2. Bi-directional Variable (Inverse Relation Shadow Variable)</h4></div></div></div><p>Two variables are bi-directional if their instances always point to each other (unless one side points to
        <code class="literal">null</code> and the other side does not exist). So if A references B, then B references A.</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/bidirectionalVariable.png"/></div><p>For a non-chained planning variable, the bi-directional relationship must be a many to one relationship.
        To map a bi-directional relationship between two planning variables, annotate the master side (which is the
        genuine side) as a normal planning variable:</p><pre><code class="language-java">@PlanningEntity
public class CloudProcess {

    @PlanningVariable(...)
    public CloudComputer getComputer() {
        return computer;
    }
    public void setComputer(CloudComputer computer) {...}

}</code></pre><p>And then annotate the other side (which is the shadow side) with a
        <code class="literal">@InverseRelationShadowVariable</code> annotation on a <code class="literal">Collection</code> (usually a
        <code class="literal">Set</code> or <code class="literal">List</code>) property:</p><pre><code class="language-java">@PlanningEntity
public class CloudComputer {

    @InverseRelationShadowVariable(sourceVariableName = "computer")
    public List&lt;CloudProcess&gt; getProcessList() {
        return processList;
    }

}</code></pre><p>The <code class="literal">sourceVariableName</code> property is the name of the genuine planning variable on the
        return type of the getter (so the name of the genuine planning variable on the <span class="emphasis"><em>other</em></span>
        side).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The shadow property, which is a <code class="literal">Collection</code>, can never be <code class="literal">null</code>. If
          no genuine variable is referencing that shadow entity, then it is an empty <code class="literal">Collection</code>.
          Furthermore it must be a mutable <code class="literal">Collection</code> because once the Solver starts initializing or
          changing genuine planning variables, it will add and remove to the <code class="literal">Collection</code>s of those
          shadow variables accordingly.</p></div><p>For a chained planning variable, the bi-directional relationship must be a one to one relationship. In
        that case, the genuine side looks like this:</p><pre><code class="language-java">@PlanningEntity
public class Customer ... {

    @PlanningVariable(graphType = PlanningVariableGraphType.CHAINED, ...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }
    public void setPreviousStandstill(Standstill previousStandstill) {...}

}</code></pre><p>And the shadow side looks like this:</p><pre><code class="language-java">@PlanningEntity
public class Standstill {

    @InverseRelationShadowVariable(sourceVariableName = "previousStandstill")
    public Customer getNextCustomer() {
         return nextCustomer;
    }
    public void setNextCustomer(Customer nextCustomer) {...}

}</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>The input planning problem of a <code class="literal">Solver</code> must not violate bi-directional relationships.
          If A points to B, then B must point to A. Planner will not violate that principle during planning, but the
          input must not violate it.</p></div></div><div class="section" title="4.3.6.3. Anchor Shadow Variable"><div class="titlepage"><div><div><h4 class="title"><a id="anchorShadowVariable"/>4.3.6.3. Anchor Shadow Variable</h4></div></div></div><p>An anchor shadow variable is the anchor of <a class="link" href="ch04.html#chainedPlanningVariable" title="4.3.5.4. Chained Planning Variable (TSP, VRP, ...)">a chained
        variable</a>.</p><p>Annotate the anchor property as a <code class="literal">@AnchorShadowVariable</code> annotation:</p><pre><code class="language-java">@PlanningEntity
public class Customer {

    @AnchorShadowVariable(sourceVariableName = "previousStandstill")
    public Vehicle getVehicle() {...}
    public void setVehicle(Vehicle vehicle) {...}

}</code></pre><p>The <code class="literal">sourceVariableName</code> property is the name of the chained variable on the same entity
        class.</p></div><div class="section" title="4.3.6.4. Custom VariableListener"><div class="titlepage"><div><div><h4 class="title"><a id="customVariableListener"/>4.3.6.4. Custom <code class="literal">VariableListener</code></h4></div></div></div><p>To update a shadow variable, Planner uses a <code class="literal">VariableListener</code>. To define a custom shadow
        variable, write a custom <code class="literal">VariableListener</code>: implement the interface and annotate it on the
        shadow variable that needs to change.</p><pre><code class="language-java">    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    @CustomShadowVariable(variableListenerClass = VehicleUpdatingVariableListener.class,
            sources = {@CustomShadowVariable.Source(variableName = "previousStandstill")})
    public Vehicle getVehicle() {
        return vehicle;
    }</code></pre><p>The <code class="literal">variableName</code> is the variable that triggers changes in the shadow
        variable(s).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If the class of the trigger variable is different than the shadow variable, also specify the
          <code class="literal">entityClass</code> on <code class="literal">@CustomShadowVariable.Source</code>. In that case, make sure
          that that <code class="literal">entityClass</code> is also properly configured as a planning entity class in the solver
          config, or the <code class="literal">VariableListener</code> will simply never trigger.</p><p>Any class that has at least one shadow variable, is a planning entity class, even it has no genuine
          planning variables.</p></div><p>For example, the <code class="literal">VehicleUpdatingVariableListener</code> assures that every
        <code class="literal">Customer</code> in a chain has the same <code class="literal">Vehicle</code>, namely the chain's
        anchor.</p><pre><code class="language-java">public class VehicleUpdatingVariableListener implements VariableListener&lt;Customer&gt; {

    public void afterEntityAdded(ScoreDirector scoreDirector, Customer customer) {
        updateVehicle(scoreDirector, customer);
    }

    public void afterVariableChanged(ScoreDirector scoreDirector, Customer customer) {
        updateVehicle(scoreDirector, customer);
    }

    ...

    protected void updateVehicle(ScoreDirector scoreDirector, Customer sourceCustomer) {
        Standstill previousStandstill = sourceCustomer.getPreviousStandstill();
        Vehicle vehicle = previousStandstill == null ? null : previousStandstill.getVehicle();
        Customer shadowCustomer = sourceCustomer;
        while (shadowCustomer != null &amp;&amp; shadowCustomer.getVehicle() != vehicle) {
            scoreDirector.beforeVariableChanged(shadowCustomer, "vehicle");
            shadowCustomer.setVehicle(vehicle);
            scoreDirector.afterVariableChanged(shadowCustomer, "vehicle");
            shadowCustomer = shadowCustomer.getNextCustomer();
        }
    }

}</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>A <code class="literal">VariableListener</code> can only change shadow variables. It must never change a genuine
          planning variable or a problem fact.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Any change of a shadow variable must be told to the <code class="literal">ScoreDirector</code>.</p></div><p>If one <code class="literal">VariableListener</code> changes two shadow variables (because having two separate
        <code class="literal">VariableListener</code>s would be inefficient), then annotate only the first shadow variable with
        the <code class="literal">variableListenerClass</code> and let the other shadow variable(s) reference the first shadow
        variable:</p><pre><code class="language-java">    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    @CustomShadowVariable(variableListenerClass = TransportTimeAndCapacityUpdatingVariableListener.class,
            sources = {@CustomShadowVariable.Source(variableName = "previousStandstill")})
    public Integer getTransportTime() {
        return transportTime;
    }

    @CustomShadowVariable(variableListenerRef = @PlanningVariableReference(variableName = "transportTime"))
    public Integer getCapacity() {
        return capacity;
    }</code></pre></div><div class="section" title="4.3.6.5. VariableListener triggering order"><div class="titlepage"><div><div><h4 class="title"><a id="variableListenerTriggeringOrder"/>4.3.6.5. VariableListener triggering order</h4></div></div></div><p>All shadow variables are triggered by a <code class="literal">VariableListener</code>, regardless if it's a build-in
        or a custom shadow variable. The genuine and shadow variables form a graph, that determines the order in which
        the <code class="literal">afterEntityAdded()</code>, <code class="literal">afterVariableChanged()</code> and
        <code class="literal">afterEntityRemoved()</code> methods are called:</p><div class="mediaobject"><img src="images/Chapter-Planner_configuration/shadowVariableOrder.png"/></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In the example above, D could have also been ordered after E (or F) because there is no direct or
          indirect dependency between D and E (or F).</p></div><p>Planner guarantees that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The first <code class="literal">VariableListener</code>'s <code class="literal">after*()</code> methods trigger
            <span class="emphasis"><em>after</em></span> the last genuine variable has changed. Therefore the genuine variables (A and B
            in the example above) are guaranteed to be in a consistent state across all its instances (with values A1,
            A2 and B1 in the example above) because the entire <code class="literal">Move</code> has been applied.</p></li><li class="listitem"><p>The second <code class="literal">VariableListener</code>'s <code class="literal">after*()</code> methods trigger
            <span class="emphasis"><em>after</em></span> the last first shadow variable has changed. Therefore the first shadow variable
            (C in the example above) are guaranteed to be in consistent state across all its instances (with values C1
            and C2 in the example above). And of course the genuine variables too.</p></li><li class="listitem"><p>And so forth.</p></li></ul></div><p>Planner does not guarantee the order in which the <code class="literal">after*()</code> methods are called for the
        <span class="emphasis"><em>same</em></span> <code class="literal">VariableListener</code> with different parameters (such as A1 and A2 in
        the example above), although they are likely to be in the order in which they were affected.</p></div></div><div class="section" title="4.3.7. Planning Problem and Planning Solution"><div class="titlepage"><div><div><h3 class="title"><a id="planningProblemAndPlanningSolution"/>4.3.7. Planning Problem and Planning Solution</h3></div></div></div><div class="section" title="4.3.7.1. Planning Problem Instance"><div class="titlepage"><div><div><h4 class="title"><a id="planningProblemInstance"/>4.3.7.1. Planning Problem Instance</h4></div></div></div><p>A dataset for a planning problem needs to be wrapped in a class for the <code class="literal">Solver</code> to
        solve. You must implement this class. For example in n queens, this in the <code class="literal">NQueens</code> class,
        which contains a <code class="literal">Column</code> list, a <code class="literal">Row</code> list, and a <code class="literal">Queen</code>
        list.</p><p>A planning problem is actually a unsolved planning solution or - stated differently - an uninitialized
        <code class="literal">Solution</code>. Therefore, that wrapping class must implement the <code class="literal">Solution</code>
        interface. For example in n queens, that <code class="literal">NQueens</code> class implements
        <code class="literal">Solution</code>, yet every <code class="literal">Queen</code> in a fresh <code class="literal">NQueens</code> class is
        not yet assigned to a <code class="literal">Row</code> (their <code class="literal">row</code> property is <code class="literal">null</code>).
        This is not a feasible solution. It's not even a possible solution. It's an uninitialized solution.</p></div><div class="section" title="4.3.7.2. Solution Interface"><div class="titlepage"><div><div><h4 class="title"><a id="solutionInterface"/>4.3.7.2. <code class="literal">Solution</code> Interface</h4></div></div></div><p>You need to present the problem as a <code class="literal">Solution</code> instance to the
        <code class="literal">Solver</code>. So your class needs to implement the <code class="literal">Solution</code> interface:</p><pre><code class="language-java">public interface Solution&lt;S extends Score&gt; {

    S getScore();
    void setScore(S score);

    Collection&lt;? extends Object&gt; getProblemFacts();

}</code></pre><p>For example, an <code class="literal">NQueens</code> instance holds a list of all columns, all rows and all
        <code class="literal">Queen</code> instances:</p><pre><code class="language-java">@PlanningSolution
public class NQueens implements Solution&lt;SimpleScore&gt; {

    private int n;

    // Problem facts
    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    // Planning entities
    private List&lt;Queen&gt; queenList;

    // ...
}</code></pre><p>A planning solution class also needs to be annotated with the <code class="literal">@PlanningSolution</code>
        annotation. Without <a class="link" href="ch04.html#automaticScanningForAnnotations" title="4.2.3.1. Automatic Scanning for Annotations">automated scanning</a>, the solver
        configuration also needs to declare the planning solution class:</p><pre><code class="language-java">&lt;solver&gt;
  ...
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  ...
&lt;/solver&gt;</code></pre></div><div class="section" title="4.3.7.3. Extract the entities from the Solution"><div class="titlepage"><div><div><h4 class="title"><a id="extractTheEntitiesFromTheSolution"/>4.3.7.3. Extract the entities from the <code class="literal">Solution</code></h4></div></div></div><p>Planner needs to extract the entity instances from the <code class="literal">Solution</code> instance. It gets those
        collection(s) by calling every getter (or field) that is annotated with
        <code class="literal">@PlanningEntityCollectionProperty</code>:</p><pre><code class="language-java">@PlanningSolution
public class NQueens implements Solution&lt;SimpleScore&gt; {
    ...

    private List&lt;Queen&gt; queenList;

    @PlanningEntityCollectionProperty
    public List&lt;Queen&gt; getQueenList() {
        return queenList;
    }

}</code></pre><p>There can be multiple <code class="literal">@PlanningEntityCollectionProperty</code> annotated members. Those can
        even return a <code class="literal">Collection</code> with the same entity class type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A @PlanningEntityCollectionProperty annotation needs to be on a member in a class with a
          @PlanningSolution annotation. It is ignored on parent classes or subclasses without that annotation.</p></div><p>In rare cases, a planning entity might be a singleton: use <code class="literal">@PlanningEntityProperty</code> on
        its getter (or field) instead.</p></div><div class="section" title="4.3.7.4. The getScore() and setScore() Methods"><div class="titlepage"><div><div><h4 class="title"><a id="getScoreAndSetScoreMethods"/>4.3.7.4. The <code class="literal">getScore()</code> and <code class="literal">setScore()</code> Methods</h4></div></div></div><p>A <code class="literal">Solution</code> requires a score property. The score property is <code class="literal">null</code> if
        the <code class="literal">Solution</code> is uninitialized or if the score has not yet been (re)calculated. The
        <code class="literal">score</code> property is usually typed to the specific <code class="literal">Score</code> implementation you
        use. For example, <code class="literal">NQueens</code> uses a <code class="literal">SimpleScore</code>:</p><pre><code class="language-java">@PlanningSolution
public class NQueens implements Solution&lt;SimpleScore&gt; {

    private SimpleScore score;

    public SimpleScore getScore() {
        return score;
    }

    public void setScore(SimpleScore score) {
        this.score = score;
    }

    // ...
}</code></pre><p>Most use cases use a <code class="literal">HardSoftScore</code> instead:</p><pre><code class="language-java">@PlanningSolution
public class CourseSchedule implements Solution&lt;HardSoftScore&gt; {

    private HardSoftScore score;

    public HardSoftScore getScore() {
        return score;
    }

    public void setScore(HardSoftScore score) {
        this.score = score;
    }

    // ...
}</code></pre><p>See the Score calculation section for more information on the <code class="literal">Score</code>
        implementations.</p></div><div class="section" title="4.3.7.5. The getProblemFacts() Method"><div class="titlepage"><div><div><h4 class="title"><a id="getProblemFacts"/>4.3.7.5. The <code class="literal">getProblemFacts()</code> Method</h4></div></div></div><p>The method is only used if Drools is used for score calculation. Other score directors do not use
        it.</p><p>All objects returned by the <code class="literal">getProblemFacts()</code> method will be asserted into the Drools
        working memory, so the score rules can access them. For example, <code class="literal">NQueens</code> just returns all
        <code class="literal">Column</code> and <code class="literal">Row</code> instances.</p><pre><code class="language-java">    public Collection&lt;? extends Object&gt; getProblemFacts() {
        List&lt;Object&gt; facts = new ArrayList&lt;Object&gt;();
        facts.addAll(columnList);
        facts.addAll(rowList);
        // Do not add the planning entity's (queenList) because that will be done automatically
        return facts;
    }</code></pre><p><span class="emphasis"><em>All planning entities are automatically inserted into the Drools working memory.</em></span> Do
        not add them in the method <code class="literal">getProblemFacts()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>A common mistake is to use <code class="literal">facts.add(...)</code> instead of
          <code class="literal">fact.addAll(...)</code> for a <code class="literal">Collection</code>, which leads to score rules failing to
          match because the elements of that <code class="literal">Collection</code> are not in the Drools working memory.</p></div><p>The <code class="literal">getProblemFacts()</code> method is not called often: at most only once per solver phase
        per solver thread.</p><div class="section" title="4.3.7.5.1. Cached Problem Fact"><div class="titlepage"><div><div><h5 class="title"><a id="cachedProblemFact"/>4.3.7.5.1. Cached Problem Fact</h5></div></div></div><p>A cached problem fact is a problem fact that does not exist in the real domain model, but is calculated
          before the <code class="literal">Solver</code> really starts solving. The <code class="literal">getProblemFacts()</code> method
          has the chance to enrich the domain model with such cached problem facts, which can lead to simpler and faster
          score constraints.</p><p>For example in examination, a cached problem fact <code class="literal">TopicConflict</code> is created for every
          two <code class="literal">Topic</code>s which share at least one <code class="literal">Student</code>.</p><pre><code class="language-java">    public Collection&lt;? extends Object&gt; getProblemFacts() {
        List&lt;Object&gt; facts = new ArrayList&lt;Object&gt;();
        // ...
        facts.addAll(calculateTopicConflictList());
        // ...
        return facts;
    }

    private List&lt;TopicConflict&gt; calculateTopicConflictList() {
        List&lt;TopicConflict&gt; topicConflictList = new ArrayList&lt;TopicConflict&gt;();
        for (Topic leftTopic : topicList) {
            for (Topic rightTopic : topicList) {
                if (leftTopic.getId() &lt; rightTopic.getId()) {
                    int studentSize = 0;
                    for (Student student : leftTopic.getStudentList()) {
                        if (rightTopic.getStudentList().contains(student)) {
                            studentSize++;
                        }
                    }
                    if (studentSize &gt; 0) {
                        topicConflictList.add(new TopicConflict(leftTopic, rightTopic, studentSize));
                    }
                }
            }
        }
        return topicConflictList;
    }</code></pre><p>Where a score constraint needs to check that no two exams with a topic that shares a student are
          scheduled close together (depending on the constraint: at the same time, in a row, or in the same day), the
          <code class="literal">TopicConflict</code> instance can be used as a problem fact, rather than having to combine every
          two <code class="literal">Student</code> instances.</p></div></div><div class="section" title="4.3.7.6. Cloning a Solution"><div class="titlepage"><div><div><h4 class="title"><a id="cloningASolution"/>4.3.7.6. Cloning a <code class="literal">Solution</code></h4></div></div></div><p>Most (if not all) optimization algorithms clone the solution each time they encounter a new best solution
        (so they can recall it later) or to work with multiple solutions in parallel.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>There are many ways to clone, such as a shallow clone, deep clone, ... This context focuses on
          <span class="emphasis"><em>a planning clone</em></span>.</p></div><p>A planning clone of a <code class="literal">Solution</code> must fulfill these requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The clone must represent the same planning problem. Usually it reuses the same instances of the
            problem facts and problem fact collections as the original.</p></li><li class="listitem"><p>The clone must use different, cloned instances of the entities and entity collections. Changes to an
            original <code class="literal">Solution</code> entity's variables must not affect its clone.</p></li></ul></div><div class="mediaobject"><img src="images/Chapter-Planner_configuration/solutionCloning.png"/></div><p><span class="bold"><strong>Implementing a planning clone method is hard, therefore you do not need to implement
        it.</strong></span></p><div class="section" title="4.3.7.6.1. FieldAccessingSolutionCloner"><div class="titlepage"><div><div><h5 class="title"><a id="fieldAccessingSolutionCloner"/>4.3.7.6.1. <code class="literal">FieldAccessingSolutionCloner</code></h5></div></div></div><p>This <code class="literal">SolutionCloner</code> is used by default. It works well for most use cases.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>When the <code class="literal">FieldAccessingSolutionCloner</code> clones your entity collection, it may not
            recognize the implementation and replace it with <code class="literal">ArrayList</code>,
            <code class="literal">LinkedHashSet</code> or <code class="literal">TreeSet</code> (whichever is more applicable). It recognizes
            most of the common JDK <code class="literal">Collection</code> implementations.</p></div><p>The <code class="literal">FieldAccessingSolutionCloner</code> does not clone problem facts by default. If any of
          your problem facts needs to be deep cloned for a planning clone, for example if the problem fact references a
          planning entity or the planning solution, mark it with a <code class="literal">@DeepPlanningClone</code>
          annotation:</p><pre><code class="language-java">@DeepPlanningClone
public class SeatDesignationDependency {
    private SeatDesignation leftSeatDesignation; // planning entity
    private SeatDesignation rightSeatDesignation; // planning entity
    ...
}</code></pre><p>In the example above, because <code class="literal">SeatDesignation</code> is a planning entity (which is deep
          planning cloned automatically), <code class="literal">SeatDesignationDependency</code> must also be deep planning
          cloned.</p><p>Alternatively, the <code class="literal">@DeepPlanningClone</code> annotation can also be used on a getter
          method.</p></div><div class="section" title="4.3.7.6.2. Custom Cloning: Make Solution Implement PlanningCloneable"><div class="titlepage"><div><div><h5 class="title"><a id="customCloning"/>4.3.7.6.2. Custom Cloning: Make <code class="literal">Solution</code> Implement <code class="literal">PlanningCloneable</code></h5></div></div></div><p>If your <code class="literal">Solution</code> implements <code class="literal">PlanningCloneable</code>, Planner will
          automatically choose to clone it by calling the <code class="literal">planningClone()</code> method.</p><pre><code class="language-java">public interface PlanningCloneable&lt;T&gt; {

    T planningClone();

}</code></pre><p>For example: If <code class="literal">NQueens</code> implements <code class="literal">PlanningCloneable</code>, it would
          only deep clone all <code class="literal">Queen</code> instances. When the original solution is changed during planning,
          by changing a <code class="literal">Queen</code>, the clone stays the same.</p><pre><code class="language-java">public class NQueens implements Solution&lt;...&gt;, PlanningCloneable&lt;NQueens&gt; {
    ...

    /**
     * Clone will only deep copy the {@link #queenList}.
     */
    public NQueens planningClone() {
        NQueens clone = new NQueens();
        clone.id = id;
        clone.n = n;
        clone.columnList = columnList;
        clone.rowList = rowList;
        List&lt;Queen&gt; clonedQueenList = new ArrayList&lt;Queen&gt;(queenList.size());
        for (Queen queen : queenList) {
            clonedQueenList.add(queen.planningClone());
        }
        clone.queenList = clonedQueenList;
        clone.score = score;
        return clone;
    }
}</code></pre><p><span class="emphasis"><em>The <code class="literal">planningClone()</code> method should only deep clone the planning
          entities.</em></span> Notice that the problem facts, such as <code class="literal">Column</code> and
          <code class="literal">Row</code> are <span class="emphasis"><em>not</em></span> normally cloned: even their <code class="literal">List</code>
          instances are <span class="emphasis"><em>not</em></span> cloned. If you were to clone the problem facts too, then you would have
          to make sure that the new planning entity clones also refer to the new problem facts clones used by the
          solution. For example, if you were to clone all <code class="literal">Row</code> instances, then each
          <code class="literal">Queen</code> clone and the <code class="literal">NQueens</code> clone itself should refer to those new
          <code class="literal">Row</code> clones.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Cloning an entity with a <a class="link" href="ch04.html#chainedPlanningVariable" title="4.3.5.4. Chained Planning Variable (TSP, VRP, ...)">chained</a> variable is devious: a
            variable of an entity A might point to another entity B. If A is cloned, then its variable must point to the
            clone of B, not the original B.</p></div></div></div><div class="section" title="4.3.7.7. Create an Uninitialized Solution"><div class="titlepage"><div><div><h4 class="title"><a id="createAnUninitializedSolution"/>4.3.7.7. Create an Uninitialized Solution</h4></div></div></div><p>Create a <code class="literal">Solution</code> instance to represent your planning problem's dataset, so it can be
        set on the <code class="literal">Solver</code> as the planning problem to solve. For example in n queens, an
        <code class="literal">NQueens</code> instance is created with the required <code class="literal">Column</code> and
        <code class="literal">Row</code> instances and every <code class="literal">Queen</code> set to a different <code class="literal">column</code>
        and every <code class="literal">row</code> set to <code class="literal">null</code>.</p><pre><code class="language-java">    private NQueens createNQueens(int n) {
        NQueens nQueens = new NQueens();
        nQueens.setId(0L);
        nQueens.setN(n);
        nQueens.setColumnList(createColumnList(nQueens));
        nQueens.setRowList(createRowList(nQueens));
        nQueens.setQueenList(createQueenList(nQueens));
        return nQueens;
    }

    private List&lt;Queen&gt; createQueenList(NQueens nQueens) {
        int n = nQueens.getN();
        List&lt;Queen&gt; queenList = new ArrayList&lt;Queen&gt;(n);
        long id = 0L;
        for (Column column : nQueens.getColumnList()) {
            Queen queen = new Queen();
            queen.setId(id);
            id++;
            queen.setColumn(column);
            // Notice that we leave the PlanningVariable properties on null
            queenList.add(queen);
        }
        return queenList;
    }</code></pre><div class="figure"><a id="d0e5059"/><p class="title"><strong>Figure 4.1. Uninitialized Solution for the 4 Queens Puzzle</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Planner_configuration/uninitializedNQueens04.png" alt="Uninitialized Solution for the 4 Queens Puzzle"/></div></div></div><br class="figure-break"/><p>Usually, most of this data comes from your data layer, and your <code class="literal">Solution</code> implementation
        just aggregates that data and creates the uninitialized planning entity instances to plan:</p><pre><code class="language-java">        private void createLectureList(CourseSchedule schedule) {
            List&lt;Course&gt; courseList = schedule.getCourseList();
            List&lt;Lecture&gt; lectureList = new ArrayList&lt;Lecture&gt;(courseList.size());
            long id = 0L;
            for (Course course : courseList) {
                for (int i = 0; i &lt; course.getLectureSize(); i++) {
                    Lecture lecture = new Lecture();
                    lecture.setId(id);
                    id++;
                    lecture.setCourse(course);
                    lecture.setLectureIndexInCourse(i);
                    // Notice that we leave the PlanningVariable properties (period and room) on null
                    lectureList.add(lecture);
                }
            }
            schedule.setLectureList(lectureList);
        }</code></pre></div></div></div><div class="section" title="4.4. Use the Solver"><div class="titlepage"><div><div><h2 class="title"><a id="useTheSolver"/>4.4. Use the <code class="literal">Solver</code></h2></div></div></div><div class="section" title="4.4.1. The Solver Interface"><div class="titlepage"><div><div><h3 class="title"><a id="theSolverInterface"/>4.4.1. The <code class="literal">Solver</code> Interface</h3></div></div></div><p>A <code class="literal">Solver</code> implementation will solve your planning problem.</p><pre><code class="language-java">public interface Solver&lt;S extends Solution&gt; {
    
    S solve(S planningProblem);

    ...
}</code></pre><p>A <code class="literal">Solver</code> can only solve one planning problem instance at a time. A
      <code class="literal">Solver</code> should only be accessed from a single thread, except for the methods that are
      specifically javadocced as being thread-safe. It is built with a <code class="literal">SolverFactory</code>, there is no
      need to implement it yourself.</p></div><div class="section" title="4.4.2. Solving a Problem"><div class="titlepage"><div><div><h3 class="title"><a id="solvingAProblem"/>4.4.2. Solving a Problem</h3></div></div></div><p>Solving a problem is quite easy once you have:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <code class="literal">Solver</code> built from a solver configuration</p></li><li class="listitem"><p>A <code class="literal">Solution</code> that represents the planning problem instance</p></li></ul></div><p>Just provide the planning problem as argument to the <code class="literal">solve()</code> method and it will return
      the best solution found:</p><pre><code class="language-java">    NQueens bestSolution = solver.solve(planningProblem);</code></pre><p>For example in n queens, the <code class="literal">solve()</code> method will return an <code class="literal">NQueens</code>
      instance with every <code class="literal">Queen</code> assigned to a <code class="literal">Row</code>.</p><div class="figure"><a id="d0e5140"/><p class="title"><strong>Figure 4.2. Best Solution for the 4 Queens Puzzle in 8ms (Also an Optimal Solution)</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/Chapter-Planner_configuration/solvedNQueens04.png" alt="Best Solution for the 4 Queens Puzzle in 8ms (Also an Optimal Solution)"/></div></div></div><br class="figure-break"/><p>The <code class="literal">solve(Solution)</code> method can take a long time (depending on the problem size and the
      solver configuration). The <code class="literal">Solver</code> intelligently wades through <a class="link" href="ch06.html#searchSpaceSize" title="6.1. Search Space Size in the Real World">the search space</a> of possible solutions and remembers the best solution it
      encounters during solving. Depending on a number factors (including problem size, how much time the
      <code class="literal">Solver</code> has, the solver configuration, ...), <a class="link" href="ch06.html#doesPlannerFindTheOptimalSolution" title="6.2. Does Planner Find the Optimal Solution?">that best solution might or might not be an optimal
      solution</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The <code class="literal">Solution</code> instance given to the method <code class="literal">solve(Solution)</code> is changed
        by the <code class="literal">Solver</code>, but do not mistake it for the best solution.</p><p>The <code class="literal">Solution</code> instance returned by the methods <code class="literal">solve(Solution)</code> or
        <code class="literal">getBestSolution()</code> is most likely <a class="link" href="ch04.html#cloningASolution" title="4.3.7.6. Cloning a Solution">a planning clone</a> of
        the instance given to the method <code class="literal">solve(Solution)</code>, which implies it is a different
        instance.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The <code class="literal">Solution</code> instance given to the <code class="literal">solve(Solution)</code> method does not
        need to be uninitialized. It can be partially or fully initialized, which is often the case in <a class="link" href="ch15.html" title="Chapter 15. Repeated Planning">repeated planning</a>.</p></div></div><div class="section" title="4.4.3. Environment Mode: Are There Bugs in my Code?"><div class="titlepage"><div><div><h3 class="title"><a id="environmentMode"/>4.4.3. Environment Mode: Are There Bugs in my Code?</h3></div></div></div><p>The environment mode allows you to detect common bugs in your implementation. It does not affect the logging
      level.</p><p>You can set the environment mode in the solver configuration XML file:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;environmentMode&gt;FAST_ASSERT&lt;/environmentMode&gt;
  ...
&lt;/solver&gt;</code></pre><p>A solver has a single <code class="literal">Random</code> instance. Some solver configurations use the
      <code class="literal">Random</code> instance a lot more than others. For example Simulated Annealing depends highly on
      random numbers, while Tabu Search only depends on it to deal with score ties. The environment mode influences the
      seed of that <code class="literal">Random</code> instance.</p><p>These are the environment modes:</p><div class="section" title="4.4.3.1. FULL_ASSERT"><div class="titlepage"><div><div><h4 class="title"><a id="environmentModeFullAssert"/>4.4.3.1. FULL_ASSERT</h4></div></div></div><p>The FULL_ASSERT mode turns on all assertions (such as assert that the incremental score calculation is
        uncorrupted for each move) to fail-fast on a bug in a Move implementation, a score rule, the rule engine itself,
        ...</p><p>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method
        <code class="literal">calculateScore()</code> more frequently than a non-assert mode.</p><p>The FULL_ASSERT mode is horribly slow (because it does not rely on incremental score calculation).</p></div><div class="section" title="4.4.3.2. NON_INTRUSIVE_FULL_ASSERT"><div class="titlepage"><div><div><h4 class="title"><a id="environmentModeNonIntrusiveFullAssert"/>4.4.3.2. NON_INTRUSIVE_FULL_ASSERT</h4></div></div></div><p>The NON_INTRUSIVE_FULL_ASSERT turns on several assertions to fail-fast on a bug in a Move implementation,
        a score rule, the rule engine itself, ...</p><p>This mode is reproducible (see the reproducible mode). It is non-intrusive because it does not call the
        method <code class="literal">calculateScore()</code> more frequently than a non assert mode.</p><p>The NON_INTRUSIVE_FULL_ASSERT mode is horribly slow (because it does not rely on incremental score
        calculation).</p></div><div class="section" title="4.4.3.3. FAST_ASSERT"><div class="titlepage"><div><div><h4 class="title"><a id="environmentModeFastAssert"/>4.4.3.3. FAST_ASSERT</h4></div></div></div><p>The FAST_ASSERT mode turns on most assertions (such as assert that an undoMove's score is the same as
        before the Move) to fail-fast on a bug in a Move implementation, a score rule, the rule engine itself,
        ...</p><p>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method
        <code class="literal">calculateScore()</code> more frequently than a non assert mode.</p><p>The FAST_ASSERT mode is slow.</p><p>It is recommended to write a test case that does a short run of your planning problem with the FAST_ASSERT
        mode on.</p></div><div class="section" title="4.4.3.4. REPRODUCIBLE (default)"><div class="titlepage"><div><div><h4 class="title"><a id="environmentModeReproducible"/>4.4.3.4. REPRODUCIBLE (default)</h4></div></div></div><p>The reproducible mode is the default mode because it is recommended during development. In this mode, two
        runs in the same Planner version will execute the same code in the same order. <span class="bold"><strong>Those two
        runs will have the same result at every step</strong></span>, except if the note below applies. This enables you to
        reproduce bugs consistently. It also allows you to benchmark certain refactorings (such as a score constraint
        performance optimization) fairly across runs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Despite the reproducible mode, your application might still not be fully reproducible because of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use of <code class="literal">HashSet</code> (or another <code class="literal">Collection</code> which has an
              inconsistent order between JVM runs) for collections of planning entities or planning values (but not
              normal problem facts), especially in the <code class="literal">Solution</code> implementation. Replace it with
              <code class="literal">LinkedHashSet</code>.</p></li><li class="listitem"><p>Combining a time gradient dependent algorithms (most notably Simulated Annealing) together with time
              spent termination. A sufficiently large difference in allocated CPU time will influence the time gradient
              values. Replace Simulated Annealing with Late Acceptance. Or instead, replace time spent termination with
              step count termination.</p></li></ul></div></div><p>The reproducible mode is slightly slower than the production mode. If your production environment requires
        reproducibility, use this mode in production too.</p><p>In practice, this mode uses the default, fixed <a class="link" href="ch04.html#randomNumberGenerator" title="4.4.5. Random Number Generator">random seed</a> if
        no seed is specified, and it also disables certain concurrency optimizations (such as work stealing).</p></div><div class="section" title="4.4.3.5. PRODUCTION"><div class="titlepage"><div><div><h4 class="title"><a id="environmentModeProduction"/>4.4.3.5. PRODUCTION</h4></div></div></div><p>The production mode is the fastest, but it is not reproducible. It is recommended for a production
        environment, unless reproducibility is required.</p><p>In practice, this mode uses no fixed <a class="link" href="ch04.html#randomNumberGenerator" title="4.4.5. Random Number Generator">random seed</a> if no seed
        is specified.</p></div></div><div class="section" title="4.4.4. Logging Level: What is the Solver Doing?"><div class="titlepage"><div><div><h3 class="title"><a id="logging"/>4.4.4. Logging Level: What is the <code class="literal">Solver</code> Doing?</h3></div></div></div><p>The best way to illuminate the black box that is a <code class="literal">Solver</code>, is to play with the logging
      level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bold"><strong>error</strong></span>: Log errors, except those that are thrown to the calling code as
          a <code class="literal">RuntimeException</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><span class="bold"><strong>If an error happens, Planner normally fails fast</strong></span>: it throws a
            subclass of <code class="literal">RuntimeException</code> with a detailed message to the calling code. It does not log
            it as an error itself to avoid duplicate log messages. Except if the calling code explicitly catches and
            eats that <code class="literal">RuntimeException</code>, a <code class="literal">Thread</code>'s default
            <code class="literal">ExceptionHandler</code> will log it as an error anyway. Meanwhile, the code is disrupted from
            doing further harm or obfuscating the error.</p></div></li><li class="listitem"><p><span class="bold"><strong>warn</strong></span>: Log suspicious circumstances.</p></li><li class="listitem"><p><span class="bold"><strong>info</strong></span>: Log every phase and the solver itself. See <a class="link" href="ch06.html#scopeOverview" title="6.8. Scope Overview">scope overview</a>.</p></li><li class="listitem"><p><span class="bold"><strong>debug</strong></span>: Log every step of every phase. See <a class="link" href="ch06.html#scopeOverview" title="6.8. Scope Overview">scope overview</a>.</p></li><li class="listitem"><p><span class="bold"><strong>trace</strong></span>: Log every move of every step of every phase. See <a class="link" href="ch06.html#scopeOverview" title="6.8. Scope Overview">scope overview</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Turning on <code class="literal">trace</code> logging, will slow down performance considerably: it is often four
            times slower. However, it is invaluable during development to discover a bottleneck.</p><p>Even debug logging can slow down performance considerably for fast stepping algorithms (such as Late
            Acceptance and Simulated Annealing), but not for slow stepping algorithms (such as Tabu Search).</p></div></li></ul></div><p>For example, set it to <code class="literal">debug</code> logging, to see when the phases end and how fast steps are
      taken:</p><pre><code class="no-highlight">INFO  Solving started: time spent (3), best score (uninitialized/0), random (JDK with seed 0).
DEBUG     CH step (0), time spent (5), score (0), selected move count (1), picked move (Queen-2 {null -&gt; Row-0}).
DEBUG     CH step (1), time spent (7), score (0), selected move count (3), picked move (Queen-1 {null -&gt; Row-2}).
DEBUG     CH step (2), time spent (10), score (0), selected move count (4), picked move (Queen-3 {null -&gt; Row-3}).
DEBUG     CH step (3), time spent (12), score (-1), selected move count (4), picked move (Queen-0 {null -&gt; Row-1}).
INFO  Construction Heuristic phase (0) ended: step total (4), time spent (12), best score (-1).
DEBUG     LS step (0), time spent (19), score (-1),     best score (-1), accepted/selected move count (12/12), picked move (Queen-1 {Row-2 -&gt; Row-3}).
DEBUG     LS step (1), time spent (24), score (0), new best score (0), accepted/selected move count (9/12), picked move (Queen-3 {Row-3 -&gt; Row-2}).
INFO  Local Search phase (1) ended: step total (2), time spent (24), best score (0).
INFO  Solving ended: time spent (24), best score (0), average calculate count per second (1625).</code></pre><p>All time spent values are in milliseconds.</p><p>Everything is logged to <a class="link" href="http://www.slf4j.org/">SLF4J</a>, which is a simple logging
      facade which delegates every log message to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a
      dependency to the logging adaptor for your logging framework of choice.</p><p>If you are not using any logging framework yet, use Logback by adding this Maven dependency (there is no
      need to add an extra bridge dependency):</p><pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</code></pre><p>Configure the logging level on the <code class="literal">org.optaplanner</code> package in your
      <code class="filename">logback.xml</code> file:</p><pre><code class="language-xml">&lt;configuration&gt;

  &lt;logger name="org.optaplanner" level="debug"/&gt;

  ...

&lt;configuration&gt;</code></pre><p>If instead, you are still using Log4J 1.x (and you do not want to switch to its faster successor, Logback),
      add the bridge dependency:</p><pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</code></pre><p>And configure the logging level on the package <code class="literal">org.optaplanner</code> in your
      <code class="filename">log4j.xml</code> file:</p><pre><code class="language-xml">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;

  &lt;category name="org.optaplanner"&gt;
    &lt;priority value="debug" /&gt;
  &lt;/category&gt;

  ...

&lt;/log4j:configuration&gt;</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In a multitenant application, multiple <code class="literal">Solver</code> instances might be running at the same
        time. To separate their logging into distinct files, surround the <code class="literal">solve()</code> call with an <a class="link" href="http://logback.qos.ch/manual/mdc.html">MDC</a>:</p><pre><code class="language-java">        MDC.put("tenant.name",tenantName);
        Solution bestSolution = solver.solve(planningProblem);
        MDC.remove("tenant.name");</code></pre><p>Then configure your logger to use different files for each <code class="literal">${tenant.name}</code>. For example
        in Logback, use a <code class="literal">SiftingAppender</code> in <code class="literal">logback.xml</code>:</p><pre><code class="language-xml">  &lt;appender name="fileAppender" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;
    &lt;discriminator&gt;
      &lt;key&gt;tenant.name&lt;/key&gt;
      &lt;defaultValue&gt;unknown&lt;/defaultValue&gt;
    &lt;/discriminator&gt;
    &lt;sift&gt;
      &lt;appender name="fileAppender.${tenant.name}" class="...FileAppender"&gt;
        &lt;file&gt;local/log/optaplanner-${tenant.name}.log&lt;/file&gt;
        ...
      &lt;/appender&gt;
    &lt;/sift&gt;
  &lt;/appender&gt;</code></pre></div></div><div class="section" title="4.4.5. Random Number Generator"><div class="titlepage"><div><div><h3 class="title"><a id="randomNumberGenerator"/>4.4.5. Random Number Generator</h3></div></div></div><p>Many heuristics and metaheuristics depend on a pseudorandom number generator for move selection, to resolve
      score ties, probability based move acceptance, ... During solving, the same <code class="literal">Random</code> instance is
      reused to improve reproducibility, performance and uniform distribution of random values.</p><p>To change the random seed of that <code class="literal">Random</code> instance, specify a
      <code class="literal">randomSeed</code>:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;randomSeed&gt;0&lt;/randomSeed&gt;
  ...
&lt;/solver&gt;</code></pre><p>To change the pseudorandom number generator implementation, specify a <code class="literal">randomType</code>:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;randomType&gt;MERSENNE_TWISTER&lt;/randomType&gt;
  ...
&lt;/solver&gt;</code></pre><p>The following types are supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">JDK</code> (default): Standard implementation (<code class="literal">java.util.Random</code>).</p></li><li class="listitem"><p><code class="literal">MERSENNE_TWISTER</code>: Implementation by <a class="link" href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons Math</a>.</p></li><li class="listitem"><p><code class="literal">WELL512A</code>, <code class="literal">WELL1024A</code>, <code class="literal">WELL19937A</code>,
          <code class="literal">WELL19937C</code>, <code class="literal">WELL44497A</code> and <code class="literal">WELL44497B</code>: Implementation
          by <a class="link" href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons
          Math</a>.</p></li></ul></div><p>For most use cases, the randomType has no significant impact on the average quality of the best solution on
      multiple datasets. If you want to confirm this on your use case, use the <a class="link" href="ch14.html" title="Chapter 14. Benchmarking And Tweaking">benchmarker</a>.</p></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'OptaPlanner', 'additional_tracking_code' : 'UA-39485370-1'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><ul class="docnav"><li class="previous"><a accesskey="p" href="ch03.html"><strong>Prev</strong>Chapter 3. Use Cases and Examples</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch05.html"><strong>Next</strong>Chapter 5. Score Calculation</a></li></ul></body></html>